/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: lepkarepka (https://sketchfab.com/lepkarepka14)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/fantastic-castle-08a018e4e7b3486dbec7b0341be3aeb4
Title: Fantastic castle
*/

import { useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { CastleModel } from "@/assets/3d-models-optimized";
import { a } from "@react-spring/three";
import * as THREE from "three";
import { useFrame } from "@react-three/fiber";
import { CastleGLTFResult, useCastleRotation } from "../model";

type Props = {
  scale: any;
  position: any;
  rotation: any;
  isRotating: boolean;
  setCurrentStage: (stage: number) => void;
  setIsRotating: (isRotating: boolean) => void;
};

export function Castle({ isRotating, setIsRotating, setCurrentStage, ...props }: Props) {
  const castleRef = useRef<THREE.Group>(null);
  const { nodes, materials } = useGLTF(CastleModel) as CastleGLTFResult;

  const { rotationSpeed, dampingFactor } = useCastleRotation(
    castleRef,
    isRotating,
    setIsRotating,
    // setCurrentStage,
  );

  useFrame(() => {
    if (!castleRef.current) return;

    // Плавное затухание вращения
    if (!isRotating) {
      rotationSpeed.current *= dampingFactor;
      if (Math.abs(rotationSpeed.current) < 0.001) {
        rotationSpeed.current = 0;
      }
    }

    // Ограничиваем скорость
    const maxSpeed = 0.01;
    rotationSpeed.current = Math.max(Math.min(rotationSpeed.current, maxSpeed), -maxSpeed);

    // Применяем вращение
    castleRef.current.rotation.y += rotationSpeed.current;

    // Определяем текущий этап на основе угла поворота
    const rotation = castleRef.current.rotation.y;
    const normalizedRotation = ((rotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
    const stage = Math.floor(normalizedRotation / (Math.PI / 2)) + 1;
    setCurrentStage(stage > 4 ? 1 : stage);
  });

  return (
    <a.group {...props} ref={castleRef}>
      <group scale={0.01} rotation={[-Math.PI / 2, 0, 0]} position={props.position || [0, -2, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <mesh
            castShadow
            scale={100}
            receiveShadow
            material={materials[".003"]}
            rotation={[-Math.PI / 2, 0, 0]}
            position={[7366.46, 2628.348, 6702.574]}
            geometry={nodes["��������������001_����������������003_0"].geometry}
          />
          <mesh
            castShadow
            scale={100}
            receiveShadow
            material={materials[".002"]}
            rotation={[-Math.PI / 2, 0, -0.917]}
            position={[-8870.991, 1117.951, 8887.213]}
            geometry={nodes["������008_����������������002_0"].geometry}
          />
          <mesh
            castShadow
            scale={100}
            receiveShadow
            material={materials[".001"]}
            rotation={[-Math.PI / 2, 0, 0]}
            position={[-1561.231, 1156.779, 8464.42]}
            geometry={nodes["������010_����������������001_0"].geometry}
          />
          <mesh
            castShadow
            scale={100}
            receiveShadow
            material={materials.material}
            rotation={[-Math.PI / 2, 0, 0]}
            position={[-1739.304, 1213.496, 5251.469]}
            geometry={nodes["������011_����������������_0"].geometry}
          />
          <mesh
            castShadow
            scale={100}
            receiveShadow
            material={materials[".004"]}
            rotation={[-Math.PI / 2, 0, 0]}
            position={[-1609.998, -270.173, 5555.747]}
            geometry={nodes["������������������_����������������004_0"].geometry}
          />
        </group>
      </group>
    </a.group>
  );
}
